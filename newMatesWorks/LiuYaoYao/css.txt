行业样式与外链样式的区别:行业样式：我自己的理解就是在html结构的head中直接写css代码，外联样式是写一个以.css结尾的
                        样式文件，通过link引入到html中，这样有利于代码的可读性。
css的权重问题：内联样式（在html元素内部）>内部样式（位于head标签内部）>外部样式>浏览器中的样式声明
                多重样式优先级顺序：内联样式>id选择器 >伪类 >属性选择器> 类选择器 >元素选择器 >通用选择器
                权重的计算：内联样式的权值最高1000
                            id选择器的权值为100
                            class类选择器的权值为10
                            html标签选择器的权值为1
                 权值越大越优先，当权值相等时，后出现的优先级大于先出现的优先级，继承的css样式不如后来指定的css样式
                 属性标有！important的优先级最大
css的盒子模型：包括边距，边框，填充和实际内容
                margin，外边距，清除边框区域，margin没有背景颜色，完全的透明
                border边框，边框周围的填充和内容，边框会受到背景颜色的影响
                padding内边距：清除内容周围的区域，会受到框中填充背景颜色的影响
                content：盒子的内容，显示文本和图像
                通常指定css元素的宽度和高度，只是指定的是content的宽度和高度，所以总的宽度是content宽+左右填充+左右边框+左右边距
                                                                                  总的高度是content高+顶部填充+底部填充+上边框+下边框+上边距+下边距
                边框的一些属性：border ：1px solid red ;第一个参数是指边框的宽度，第二个参数是指边框是实线，第三个参数是指边框的颜色是红色的
css 的定位于浮动：display：block可以让行内元素表现的像块级元素一样
                  css的三种定位机制：普通流，浮动，绝对定位
                  css position属性值：static,relative,absolute,fixed
                                      relative:相对于当前的框偏离某个位置
                                      absolute：元素框从文档流中完全消失，并相对于其包含块定位,绝对定位的元素的位置是相对于最近已定位的父元素，如果元素没有已定位的父元素
                                                那么它的位置相对于<html>
                                      fixed：作用类似于absolute，只是包含块是视窗本身,元素位置相对于浏览器窗口是固定的位置，机试窗口是滚动的它也不会移动
                                      z-index属性指定了一个元素的堆叠顺序（那个元素应该放在前面或者后面）一个元素可以有正数和负数的堆叠顺序
                                      overflow: scroll;溢出就滚动
                                      overflow: hidden;溢出就隐藏
                                      overflow: auto;溢出自动处理
                                      清除浮动使用clear,clear属性指定元素两侧不能出现浮动元素，
 栅格布局：
            圣杯布局：是一种三列布局，两边定宽，中间自适应，圣杯布局的原理就是当子元素处于浮动状态时，设置负margin，子元素会覆盖到兄弟元素之上
            栅格布局：简单的理解就是在一个容器中的一行被分成了很多列，这些列的个数最多不能超过12个
  单行文本溢出显示省略号：text-overflow：ellipse，部分浏览器还需要加宽度的width属性


  dom：dom是文档对象模型，通过dom可以访问所有的html元素，联通他们所包含的文本和属性，可以通过三种方式查找（1）通过id查找html元素，返回类型是一个对象
       （2）通过标签名找到html元素，返回类型是数组（3）通过类名找到html元素，返回类型是数组
       javascript能够创建动态的html内容，使用document.write()可用于直接向html输出流写内容,绝对不能再文档加载完后使用document.write,这样会覆盖文档
       改变html内容可以使用innerHTML属性，（这个属性主要是通过id获取到的）
       改变html样式document.getElementById(id).style.property=new style
       dom的事件操作：this的重点操作,this可以被当成id传入到函数里面，this也可以代表一个对象，onload事件会在用户进入或者离开页面时被触发，onload事件可用于处理cookie
       onmouseover和onmouseout事件可用于在用户的鼠标移至html元素上方或移出元素时触发函数
       onmousedown,onmouseup以及onclick构成了鼠标点击事件的所有部分，首先当点击鼠标按钮时，会触发onmousedown事件，当释放鼠标按钮时，会触发onmouseup事件，左后，当完成鼠标点击时，会触发onclick事件
       普通绑定事件和用addEventListenet添加事件有什么区别：
       （1）onclick添加事件不能绑定多个事件，后面绑定的会覆盖前面的。addEventListenet能添加多个事件绑定，按顺序执行
       （2）普通方式绑定事件后，不可以取消。addEventListenet绑定后则可以用removeEventListener取消
       （3）addEventListenet的第三个参数为true，浏览器采用Capture（捕捉）
                                        为false，浏览器采用bubbing（冒泡）--建议使用
            element.addEventListener(event, function, useCapture);第一个参数可以是click，或者mousedown，mouseover，第二个参数是事件触发后调用的函数

事件传递有两种方式：冒泡与捕获，事件传递定义了元素事件触发的顺序。如果你将 <p> 元素插入到 <div> 元素中，用户点击 <p> 元素, 哪个元素的 "click" 事件先被触发呢？
                    在冒泡中，内部元素的事件会先被触发，然后再触发外部元素，即： <p> 元素的点击事件先触发，然后会触发 <div> 元素的点击事件。
                    在捕获中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即： <div> 元素的点击事件先触发 ，然后再触发 <p> 元素的点击事件。
                    铺获先发生，冒泡后发生
                    创建新的html dom元素，在文档对象模型中，每一个节点都是一个对象，dom节点有三个重要的属性，分别是1：nodename节点的名称，nodevalue节点的值3：nodetype节点的类型
json：仅仅是发送一个 Ajax 请求，然后将服务器返回的 JSON 数据赋值给一个变量即可，将 String 对象编码为 JSON 格式时，只需处理好特殊字符即可。另外，必须用 (") 而非 (') 表示字符
json是以键值对的形式存在的，"key":"value";的形式来组织；
       在window浏览器对象中，提供了一个叫JSON的属性（window.JSON），里面提供了两个方法。
       JSON.parse：把JSON格式的字符串转换为JSON格式的对象
       JSON.stringify：把JSON格式的对象转换为JSON格式的字符串
 cookie数据存放在客户的浏览器上，session数据放在服务器上
 session中保存的是对象，cookie中保存的是字符串
 cookie、localStorage、sessionStorage的用户和区别：共同点：都是保存在浏览器端，且是同源的
    区别：1：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器
    仅在本地保存，cookie还有路径的概念，可以限制cookie只属于某个路径下
    2、存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大
    3、数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭
    4、作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的
    5、web Storage支持事件通知机制，可以将数据更新的通知发送给监听者
    6、web Storage的api接口使用更方便
    sessionStorage与页面js数据对象的区别 ：页面中一般的js对象的生存期仅在当前页面有效，因此刷新页面或转到另一页面这样的重新加载页面的情况，数据就不存在了
                                而sessionStorage只要同源的同窗口中，刷新页面或进入同源的不同页面，数据始终存在，也就是说只要浏览器不关闭，数据仍然存在。
     发布-订阅模式：事件监听，事件触发，事件取消
     tcp:TCP协议建立连接，产生会话，面向字节流，进行可靠的传输，确保数据从一个节点完整的到另外一个节点。
     了解Http的状态码，特别是200、302、404、500、502
     200(成功) 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
     302 (临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
     404 (未找到) 服务器找不到请求的网页。
     500 (服务器内部错误) 服务器遇到错误，无法完成请求。
     502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。
